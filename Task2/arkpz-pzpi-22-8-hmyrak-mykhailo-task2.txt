МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ




Звіт


До лаборотної роботи №2


З дисципліни:
«Аналіз та рефакторінг коду»





	


Виконав:                                                                                        
Ст. гр. ПЗПІ-22-8                                                                                                       
Гмирак Михайло Дмитрович                                                                                      
	
Перевірив:
ст. викладач кафедри ПІ 
Сокорчук Ігор Петрович





Харків 2024
     

     2.1 Мета роботи: Розробити базу даних для серверної частини програмної системи та прикладного програмного інтерфейсу. 
     
     2.2 Хід роботи 
     2.2.1 Опис інженерних рішень 
     
     Вибір технологій: 
     * .NET 6 було обрано завдяки його високій продуктивності, кросплатформеності та зручності створення веб-додатків.
     * Entity Framework Core використовується як ORM для взаємодії з базою даних, що спрощує роботу з даними, дозволяючи писати запити на C# замість SQL.
     * Managment Studio обрано як СУБД через її відповідність стандартам SQL, потужність та підтримку розширених функцій.
     Основні інженерні рішення:
     1. Структура проекту:
     Проєкт побудовано за архітектурним підходом MVC (Model-View-Controller), що забезпечує модульність та зручність підтримки: 
     * Model: Файли у папці Models, такі як Book.cs, Category.cs, User.cs, відповідають за опис доменних сутностей та їхню взаємодію з базою даних через контекст (lib4Context.cs).
     * Controller: Файли, такі як BooksEndpoints.cs, UsersEndpoints.cs, ReadersEndpoints.cs, реалізують REST API та логіку обробки запитів.
     * View: У контексті REST API, представлення даних реалізовано через JSON-відповіді.
     2. Залежності:
     * Dependency Injection (DI): У .NET використовується вбудований контейнер залежностей для автоматичного управління життєвим циклом об'єктів. Це спрощує тестування та рефакторинг.
     * Конфігурація через appsettings.json для зберігання налаштувань, зокрема підключення до бази даних.
     3. Реалізація функціональності:
     * Ендпоінти: Усі контролери розділено на окремі класи (BooksEndpoints.cs, UsersEndpoints.cs тощо) для забезпечення чіткого розподілу відповідальності.
     * Entity Framework Core: Робота з базою даних через контекст lib4Context.cs, що дозволяє використовувати LINQ-запити та автоматично генерувати SQL.
     * Валідація даних: Використання атрибутів, таких як [Required], [MaxLength], для перевірки даних на рівні моделей.
     * Swagger: Реалізовано інтеграцію зі Swagger через SwaggerConfig.cs для автоматичної генерації документації API.
     
     2.2.2 Специфікація API для взаємодії серверної частини з клієнтами
     
     Вибір REST API:
     Вибір REST API зумовлений наступними причинами: 
     – простота реалізації та підтримки: REST базується на стандартних методах HTTP (GET, POST, PUT, DELETE), що полегшує розробку і підтримку; 
     – широка сумісність: REST підтримується більшістю мов програмування і фреймворків, що робить його універсальним рішенням; 
     – легка масштабованість: REST дозволяє легко масштабувати систему; – стандартний формат даних: дані передаються у форматах JSON або XML, які зрозумілі для клієнтів і серверів; 
     – REST є популярним вибором для веб-додатків, тому для нього доступно багато інструментів, бібліотек та прикладів. 
     Використано шаблон MVC (Model-View-Controller) — це популярний архітектурний шаблон, який розділяє програму на три основні компоненти: Model, View, Controller.
     1. Model:
     * Моделі, такі як Book, User, Category, розташовані у папці Models.
     * Взаємодія з базою даних здійснюється через контекст lib4Context.cs, де описано всі таблиці та зв'язки.
     * Атрибути моделей визначають валідацію та обмеження (наприклад, [Required], [MaxLength]).
     2. View:
     * Представлення даних реалізується у вигляді JSON-відповідей, які формуються у контролерах (наприклад, BooksEndpoints.cs).
     * На клієнтську сторону передаються об'єкти, що легко перетворюються у потрібні формати.
     3. Controller:
     * Файли з ендпоінтами, такі як BooksEndpoints.cs, обробляють запити клієнтів. Кожен метод відповідає за обробку конкретного HTTP-запиту (GET, POST, PUT, DELETE).
     Приклад коду CRUD- Операцій наведений у додатку А.
     Масштабування та гнучкість:
     * Поділ ендпоінтів за доменними сутностями полегшує додавання нової функціональності.
     * Можливість розширення API через підключення нових сервісів або модулів.
     

     Рисунок 2.1  –  Post-запит до таблиці Books
     

     Рисунок 2.2  –  Get-запит до таблиці Books


     Рисунок 2.3  –  Get-запит з параметром до таблиці Books
     

     Рисунок 2.4  –  Put-запит до таблиці Books
     

     Рисунок 2.5  –  Delete-запит до таблиці Books
     
     2.2.3 Логіка взаємодії серверної частини з БД
     
     Моделі (Entities):
     Моделі у проєкті (файли у папці Models, наприклад, Book.cs, User.cs, Category.cs) описують структуру даних, які зберігаються в базі даних.
Вони відповідають таблицям у базі та забезпечують взаємодію з ORM (Entity Framework Core). Атрибути визначають валідацію та типи даних.
     
     
     1 public class Book
     2 {
     3     public int Id { get; set; }
     4     public string Title { get; set; }
     5     public string Author { get; set; }
     6     public int CategoryId { get; set; }
     7     public Category Category { get; set; }
     8 }
     
     Репозиторії (Repositories):
     Операції з базою даних виконуються через контекст lib4Context.cs, який є реалізацією DbContext. У проєкті використовується підхід Repository-less, коли замість створення окремих інтерфейсів для репозиторіїв, операції виконуються безпосередньо через контекст.
     Приклад коду з використанням підхіду Repository-less наведений у додатку Б.
     
     Конфігурація бази даних:
     Параметри підключення до бази даних зберігаються у файлі appsettings.json.
     
     2.2.4 Логіка взаємодії серверної частини з клієнтами
     
     Контролери (Controllers):
     Контролери (наприклад, BooksEndpoints.cs, UsersEndpoints.cs) обробляють HTTP-запити від клієнтів. Вони викликають методи взаємодії з базою через контекст й повертають результат у форматі JSON.

     2.2.5 Графічні ілюстрації (рисунки)
     
      Для більшого розуміння створено графічні ілюстрації, де виділено основний сценарій використання системи. Також створено дві діаграми до бази даних для демонстрації зв’язків та структури таблиць.
     

     Рисунок 2.6  –  UML-діагарма прецедентів для серверної частини
     

     Рисунок 2.7 – ER діаграма
     

     Рисунок 2.8  –  Діаграма структури БД

     Висновки: під час роботи було розроблено базу даних для серверної частини програмної системи та прикладного програмного інтерфейсу.
Посилання на відеоролик: https://youtu.be/XE5iNqugl_c

     
     
     
     
     
     
     
     


















     Додаток А
     Приклад коду CRUD- Операцій
     
     1 // GET: Отримати всі книги
     2 endpoints.MapGet("/books", () => db.Books.ToList())
     3     .RequireAuthorization();
     4
     5 // POST: Додати нову книгу
     6 endpoints.MapPost("/books", (Book book) => {
     7      db.Books.Add(book);
     8      db.SaveChanges();
     9      return book;
     10 }).RequireAuthorization();
     11
     12 // DELETE: Видалити книгу за ID
     13 endpoints.MapDelete("/books/{id}", (int id) => {
     14      var book = db.Books.Find(id);
     15      if (book == null) return Results.NotFound();
     16      db.Books.Remove(book);
     17      db.SaveChanges();
     18      return Results.NoContent();
     19 }).RequireAuthorization();
     
     
     
     
     
     
     
     
     Додаток Б
     Використання підхіду Repository-less
     
     1 endpoints.MapGet("/books/{id}", (int id) =>
     2 {
     3     var book = db.Books
     4         .Include(b => b.Category)
     5         .Include(b => b.Items)
     6         .Include(b => b.BooksPeople)
     7         .Where(b => b.BookId == id)
     8         .Select(b => new
     9         {
     10            b.BookId,
     11            b.Title,
     12            b.Isbn,
     13            b.Pages,
     14            b.Publish,
     15            b.CategoryId,
     16            CategoryName = b.Category.Name,
     17            b.Class,
     18            b.Lang,
     19            b.Year,
     20            Items = b.Items.Select(i => new
     21            {
     22                i.ItemId,
     23                i.ReaderId,
     24                i.Available,
     25                i.Description
     26            }),
     27            People = b.BooksPeople.Select(bp => new
     28            {
     29                bp.PersonId,
     30                bp.Person.Name,
     31                bp.RoleId
     32            })
     33        })
     34        .FirstOrDefault()
     35
     36     if (book == null)
     37     {
     38         return Results.NotFound()
     39     }
     40
     41     return Results.Ok(book)
     42 }).RequireAuthorization()
2

